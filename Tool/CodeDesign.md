- [1. Pragmatic Programmer](#1-pragmatic-programmer)
    - [1.1 学习和进步](#11-学习和进步)
        - [1.1.1 知识的投资](#111-知识的投资)
        - [1.1.2 提高效率](#112-提高效率)
    - [1.2 沟通和交流](#12-沟通和交流)
        - [1.2.1 团队合作](#121-团队合作)
        - [1.2.2 团队组织](#122-团队组织)
        - [1.2.3 沟通交流](#123-沟通交流)
        - [1.2.4 用户反馈](#124-用户反馈)
    - [1.3 设计和开发](#13-设计和开发)
        - [1.2.1 需求确认](#121-需求确认)
        - [1.2.2 文档和注释](#122-文档和注释)
        - [1.2.3 程序设计](#123-程序设计)
        - [1.2.4 代码实现](#124-代码实现)
        - [1.2.5 测试](#125-测试)
        - [1.2.6 程序维护](#126-程序维护)
- [2. Java](#2-java)
    - [2.1 类的设计](#21-类的设计)
        - [2.1.1 构造方法](#211-构造方法)
        - [2.1.2 通用方法](#212-通用方法)
        - [2.1.3 方法设计](#213-方法设计)
        - [2.1.4 访问管理](#214-访问管理)
        - [2.1.5 继承](#215-继承)
        - [2.1.6 枚举](#216-枚举)
    - [2.2 方法实现](#22-方法实现)
        - [2.2.1 类型管理](#221-类型管理)
        - [2.2.2 资源管理](#222-资源管理)
        - [2.2.3 异常管理](#223-异常管理)
        - [2.2.4 泛型](#224-泛型)
        - [2.3 高级特性](#23-高级特性)
        - [2.3.1 Lambda和Stream](#231-lambda和stream)
        - [2.3.2 并发实现](#232-并发实现)
        - [2.3.3 序列化](#233-序列化)
        - [2.3.4 注解](#234-注解)


# 1. Pragmatic Programmer

### 1.1 学习和进步

##### 1.1.1 知识的投资

- 持续学习的过程本质上就是投资
- 分散学习不同领域的知识
- 思考未来的知识的应用潜力,并以此调整在不同知识上投入的精力
- 每年学一门语言,每个季度读一本技术书/学习一门公开课

##### 1.1.2 提高效率

- 积极使用自动化工具管理代码,文档,测试,部署
- 通过高级语言抽象定义功能,尝试使用自动化工具生成代码
- 尽可能使用自动化脚本部署项目,确保部署过程可重复

### 1.2 沟通和交流

##### 1.2.1 团队合作

- 积极和组员交换知识,减少重复工作
- 提问的时候要尽可能具体,并且先在网上查找答案
- 遇到问题时,先寻找并提供可能的解决方案,而不是找借口

##### 1.2.2 团队组织

- 每个人都有责任确保代码质量,并通过品牌效应提高凝聚力
- 基于工作内容组织团队,而不是岗位,每个团队都需要技术和行政组长
- 技术组长负责工作分配,行政组长负责进度管理和资源调度

##### 1.2.3 沟通交流

- 明确自己要沟通的内容,并确保表达方式没有逻辑问题
- 了解听众的水平,用听得懂的语言表达
- 促进听众和自己的互动,增强积极性

##### 1.2.4 用户反馈

- 开工前设计好工作框架,并提供明确地方法展示工作进度
- 做好工作量估算,并在工作进度中展示,估算的越细致结果越准确
- 尽早做出Prototype来获得用户体验,但所有人必须知道当前开发的是Prototype
- Prototype应该不关注细节,只关注功能,将来会被丢弃重写
- 通过多开发一点功能给用户惊喜
  
### 1.3 设计和开发

##### 1.2.1 需求确认

1. 需求信息
  - 程序的目标和适用范围
  - 程序的运行条件和触发对象
  - 程序的成功/失败运行的结果
2. 主要成功场景
  - 提供主要成功场景的参数和数据范围
  - 给出成功场景下的运行案例
  - 明确成功场景的发生频率
3. 相关信息
   - 确定开发优先级
   - 预估开发时间和步骤,提供开发周期
   - 明确性能目标/限制
4. 需求变化
   - 分析程序的可扩展性
   - 提供程序的潜在问题

##### 1.2.2 文档和注释

- 在设计代码并沟通需求时,就可以开始写文档
- 文档是超文本标记语言,基于源代码中的内容自动生成
- 文档中应该提供字典,明确项目中一些特殊术语的含义
- 注释起到概括作用,<u>讲明代码的目的</u>,而不是解释代码

##### 1.2.3 <u>程序设计</u>

- 正交性: 代码中的每个部分都是独立的,修改一个部分不会影响其他部分
- 隔离度检验: 修改一个部分,看看其他部分是否需要修改,尽可能与第三方库隔离
- 做决策的时候要考虑可逆性和长期影响
- 尽可能使用Metadata来代替代码,如使用配置文件来决定常量和工作流
- Design By Contract: 明确代码的前置条件,后置情况,不变量
- 基于功能划分组件和模块,并使用中间件/白板系统协调

##### 1.2.4 代码实现

- <u>程序中不要有重复的内容,相同逻辑的内容尽可能使用自动化工具生成</u>
- 用类方法来设置和获取变量,而不是直接访问变量,方便扩展功能
- 当出现无法恢复的错误时,应该让代码崩溃,而不是抛出异常继续传递错误
- 常使用断言检验参数的正确性,但检验过程汇总不要包含逻辑
- 申请资源和释放资源要成对出现,并且始终按照相同的顺序

##### 1.2.5 测试

- 测试数据应该有不同规模,且同时包含真实,边界,异常和人工数据
- 在开发时就应该添单元测试,从而及时尽早发现问题
- 集成测试在测试组件交互的同时也要记录资源消耗情况,通过回归测试比较性能
- 出现过的bug必须加入到测试用例中,确保不会出现第二遍
- 测试员可以通过添加虚假错误来检验测试的覆盖性,
- 用于测试组件之间的交互和资源消耗

##### 1.2.6 程序维护

- Debug前确保没有编译错误,并优先考虑自己的问题,平台通常没有问题
- 没有必要以代码可读性和设计合理性为代价来提高性能
- 当代码出现大量重复逻辑/性能瓶颈/过时功能/高耦合度时,需要及时重构

# 2. Java

### 2.1 类的设计

##### 2.1.1 构造方法
- 用静态工厂方法构造对象
- 用静态Builder类构造多参数对象
- 单例对象的构造方法必须私有或者通过Enum实现

##### 2.1.2 通用方法
- equals的方法要遵循5原则: 自反性,对称性,传递性,一致性,非空性
- 重写equals方法时,总是要重写hashCode方法,需要考虑对象所有属性,可以使用Autovalue工具
- 实例比较有意义时,需实现Comparable接口
- 必须以可读性较强的方法重写toString方法,并提供访问字符串信息的方法
- 
##### 2.1.3 方法设计
- 使用可变参数列表的时候,需要认真考虑无参数的情况,建议强制至少一个参数
- 构造函数和非纯函数需要检查参数合法性,且文档中要明确参数类型
- 尽可能使用静态方法和静态成员变量,因为可以减少每个实例内存占用
- 尽可能使用接口来定义对象和参数类型,而不是具体的类
- 尽可能使用for-each循环,而不是for/while循环

##### 2.1.4 访问管理
- 尽可能限制方法和成员变量的可见性,公有类不要把变量设置为public,否则会让外部依赖的代码难以维护
- 每个文件只能有一个顶级类,防止外部导入时的歧义
- 对引用类型的成员变量,应该在传入和传出的时候进行保护,防止外部修改

##### 2.1.5 继承
- 使用组合代替跨包继承,因为如果外部包修改父类,子类会发生错误
- 可被继承的类必须有明确的文档说明,确保子类开发者了解运行逻辑
- 当类非常抽象时,使用接口更安全,因为可以避免子类的错误,但是骨架类在特定情况下有优势

##### 2.1.6 枚举
- 尽可能用枚举代替Int/Switch场景
- 标签类的实现是非常不合理的,应该用多态或者枚举来代替
- 不要使用枚举的序数,而是添加属性或者使用EnumMap保存索引
- 用EnumSet替代Bit Fields实现不同实例的组合

### 2.2 方法实现

##### 2.2.1 类型管理
- 减少局部变量的作用域,可以在第一次使用的地方声明
- 能同时用原始类型和装箱类型的时候,优先使用原始类型
- 高精度计算的时候使用decimal或者移位到int
- 减少字符串类型的使用,特别是拼接,尽量将有效信息转换到类或者Enum
- 从逻辑上,方法返回空集合往往比返回null更好
- Optional的本质是让用户处理空值,非必要情况下不要使用Optional

##### 2.2.2 资源管理
- 尽量减少程序中new的使用,因为会显式地创建新对象
- 对象不再使用时,应该将其引用置为null,否则会泄露内存
- 尽可能使用try-with-resources来管理和释放资源
- 不要使用外部语言方法,因为内存影响不可控

##### 2.2.3 异常管理
- 在底层API可以正常抛出异常的情况下,没必要再额外检查
- 只有在异常可以处理的时候才抛出,否则应该让程序崩溃
- 文档中应该有方法会抛出异常的明确说明,且异常的字符串信息应该尽可能具体
- 抛出异常的时候应该保留失败原子性
- 不要忽略异常,除非有非常明确的理由,且需要文档说明

##### 2.2.4 泛型
- 使用泛型集合而不是数组定义参数类型,这样可以在编译器提前发现错误
- 设计类和方法的时候,尽可能使用泛型增加可读性和约束性
- 方法生产者泛型通常使用extends,消费者泛型通常使用super
- 类型安全的异构容器可以用类作为Key储存不同类型的值

##### 2.3 高级特性

##### 2.3.1 Lambda和Stream
- lambda函数必须很短,且输入输出的参数类型很容易推断
- 尽可能使用标准函数接口来定义lambda
- 没有必要把所有循环都换成stream,因为会影响可读性
- forEach不适合用于计算stream中的值,因为本质和for没有区别
- 在数据量不大的时候,返回集合类比返回stream更好
- Stream的并行只适合于简单算法,复杂算法反而会降低性能

##### 2.3.2 并发实现
- 尽可能减少同步区域的代码,且同步区域不要调用外部方法,否则会有未知行为
- 尽量用线程池而不是自己管理线程,线程数量最好小于核心数量,且提高线程效率
- 充分使用Java并发库的工具类

##### 2.3.3 序列化
- Java原生序列化工具不安全,应该更多地使用Json或者Protobuf等第三方工具
- 实现序列化会增加维护和测试的负担,如果一定要实现,需要自己实现序列化方法,并添加版本号
- 使用静态序列化代理类实现序列化方法是更安全的选择
  
##### 2.3.4 注解
- 用注解和解析器配合反射来添加测试和检验,而不是基于方法名
- 用override从而在编译器发现错误
- 接口往往比注解更加好,因为可以更方便地定位错误或添加功能
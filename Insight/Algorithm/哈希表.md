# 哈希表

把无限的key映射到有限的slot中

load factor $\alpha=\frac{n}{m}$（哈希表中平均的key的数量为$n,\alpha$就是链表的平均长度）

load factor会**随着数据的变化一起动态变化**

### 1. 链表哈希碰撞问题

- slot后面用链表扩大

- $\mathbb{E}=\Theta(1+\alpha)$



### 2. 开放寻址法

- 没有链表
- $n$必须小于$m$
- 碰撞概率$\mathrm{Pr}(\text{Probe})=\prod\frac{n}{m}\frac{n-1}{m-1}...\leq1+\alpha(1+\alpha(1+\alpha...))\leq1+\alpha+\alpha^2...=\frac{1}{1-\alpha}$
- 需要定期扩大$m$



### 3. Universal Hashing 全域哈希

 1. 有$|H|$个哈希函数,对于任意两个key,**随机取出的hash函数**使他们碰撞的概率是$\frac{1}{m}$

 2. 如果有n个key,且哈希表共$m$个slot,则对于任意$x,y\in keys,x\neq y$,随机选择哈希函数使他们碰撞的概率是$\frac{n-1 }{m}$

 3. **构造方法**

    - 选定m为质数

    - 把任意key分解成$r+1$位(m进制)

    - **随机取哈希函数方法**

      随机生成一个r位的m进制数$\alpha$,生成如下哈希函数
      $$
      H(key) = (key\cdot\alpha)\mod m
      $$
      哈希函数总数: $|H|=m^{r+1}$

4. 如果$\alpha$和$m$互质,则必然存在$\alpha^{-1}$使得$\alpha\alpha^{-1}\mod m=1$



### 4. Perfect Hashing 完全哈希

- 给定一个固定的key集合,哈希表有$m=O(n)$个槽,且需要**保证最差情况**下查找为$O(1)$

1. 构建两层哈希表,**在第二层没有碰撞**
2. 第一级使用Universal Hashing,第一层Hash过后会得到
   - 指向第二层特定哈希表的指针
   - 一个特定数字,配合key在第二层进行Hash
3. 第一层Hash有$n$个槽,第二层第$i$个Hash有$n_i^2$个槽 (因为keys的集合已知,且第一个Hash的函数在程序开始的时候可知,则可以得出$n_i$)



### 5. 平摊分析

#### 5.1 动态增长哈希表

- 每次$n\text{(\# keys) }\approx m\text{(\# slots) }$时,slot数扩大一倍

- **平均**插入时间是$\Theta(1)$

#### 5.2 记账法分析 (Accounting Method)

- 每次操作可以获取固定的费用,例如(3)

- 每次操作需要支付不同的费用(扩表时需要$n$,平时是$1$

#### 5.3 势能方法 (Potential Method)

- **关键在于找到合理的函数**$\Phi$将数据结构映射到$\mathbb{R}, \Phi(D(0))\rightarrow0$

- 操作$i$将$D(i-1)\rightarrow D(i)$,支付$c_i$作为费用

- 平摊代价 $\hat{c_i}=c_i + \Phi(D(i-1)-\Phi(D(i))$  (势能的变化加上费用)

  $\sum_i^n\hat{c_i} \geq \sum_i^nc_i + \Phi(D(i)) $ 平摊代价**(就是复杂度)**总和大于实际代价

- 对于动态增长哈希表 $\Phi(D(i))=2i-\log \lceil i\rceil$ (根据扩大频率得出$\log \lceil i\rceil$)


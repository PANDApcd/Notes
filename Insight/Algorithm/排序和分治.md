# 排序

### 1. 分而治之

基于Master Theorem,判断$f(n)$和$n^{\log_b a}$的关系 

$T(n) = aT(n/b) + f(n)$

 1. binary search

    $T(n)=T(n/2)+O(1)\rightarrow T(n)=\Theta(\log n)$

 2. X^n次方相乘

 3. 求第n个斐波那契数 
    $$
    \left[
    \begin{array}{1}
    F_{n+1} & F_n\\
    F_n & F_{n-1}
    \end{array}
    \right]=\left[
    \begin{array}{1}
    1 & 1\\
    1 & 0
    \end{array}
    \right]^n
    $$

4. VLSI布局问题（给定$n$个结点,求面积最小的布局）

   H型布局 

   宽度 $L(n)=2L(n/4)+O(1)\rightarrow L(n)=\Theta(\sqrt{n})$

   面积 $S(n)=\Theta(n)$

   
   
   树型布局 
   
   ​	高度 $H(n)=H(n/2)+O(1)\rightarrow H(n)=\Theta(\log n)$
   
   ​	宽度 $W(n)=2W(n/2)+O(1)\rightarrow W(n)=\Theta(n)$
   
   ​	面积 $S(n)=\Theta(n\log n)$



### 2. 比较排序

1. insert sort,复杂度是 $O(n^2)$

2. merge sort
   - 关键在于merge
   - $T(n) = 2T(n/2) + f(n)$ 需要merge  $\log n$次,每次耗时n
   - stable
   
3. quick sort

   - inplace,不需要额外内存

   - 一定要随机取pivot

     得到递归式 $T(n)=\sum_{k=0}^{k=n-1}x_k(T(k)+T(n-k-1)+\Theta(n))$

4. **比较排序的时间复杂度不会低于**$O(n\log n)$

   比较排序决策树模型的叶子节点就是各种排序的可能,**有**$n!$**个叶子节点**

   因此高度就是$\Theta(n\log n)$



### 3. 非比较排序

 1. count sort

    维护一个表记录每个元素出现的次数,再反向遍历输入在表中的value

    复杂度为$O(k+n),k$是元素的大小范围（初始化和累加时需要）

2. radix排序（stable)

   先按照最后一位排序，再往前

   **使用count sort对每一位数字排序**

   重新设置数字的位数（如2进制位数变成16进制）,变化比例为$\log n$



### 4. 随机选择

 1. 用quick sort思想进行partition，复杂度为$O(n)$

 2. 根据pivot的位置,进行递归partition

    $T(n) = T(n/k) + O(n)$

3. **更优方案**

   - N个数字分大小为5的组，每组求median,总共用$O(N)$
- 获得$\frac{N}{5}$个组，求每组median的median作为pivot，用时$T(\frac{N}{5})$
   - 可以知道有$\frac{3}{10}N \text{个元素}\leq p\leq\frac{3}{10}N\text{个元素}$
- 可能有$0.3\sim0.7N$个元素比$p$小,反之亦然（pivot的位置在0.3~0.7之间）
  

最终得到 $T(N)\leq T(\frac{N}{5})+T(\frac{7N}{10})+\Theta(N)\rightarrow T(N)=O(N)$
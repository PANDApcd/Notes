# 缓存算法

### 1. 符号和概念

- $B$ 缓存中1个block的大小,每次传输一个$B$有固定的时间
- $M$ 缓存的总大小

- $MT(N)$: 从硬盘往缓存传输$N$数据的耗时
- 缓存无关算法: 可以在任意$B,M$0下高效运行,**无论在几层缓存结构中**

### 2 数组(大小为N)算法

#### 2.1 遍历数组

<img src="C:\Users\PANDA\AppData\Roaming\Typora\typora-user-images\image-20210501104006867.png" alt="image-20210501104006867" style="zoom:33%;" />	

内存中取数据的Time是$O(N/B+2)$

$O(2)$因为可能数组头和尾可能没有和block对齐

#### 2.2 二分搜索

需要查询$O(\log_2N)$次数据,但是当$N=B$时就没有需要传输耗时

$MT(N)=O(\log_2N)-O(\log_2B)=O(\log_2\frac{N}{B})$

#### 2.3 随机查找

- 计算$MT(N)$
  - 找$\frac{N}{5}$个subarray的中位数,$MT=O(\frac{N}{B})$
  - 找$\frac{N}{5}$的中位array的中位数,$MT(N)=MT(\frac{N}{5})$
  - 根据pivot递归找$MT(N)=MT(\frac{3}{4}N)$
  - $MT(N)=MT(\frac{3}{4}N)+MT(\frac{N}{5})+O(\frac{N}{B})$
- 计算叶节点数量$L(N)=L(N/5)+L(\frac{3N}{4})\rightarrow L(N)\approx O(N^{0.8393})$
  - 需要传输$N^{0.8393}$次
  - 当$B\geq N^{0.2}\rightarrow O(\frac{N}{B})=\Omega(N^{0.8})\rightarrow MT(N)=\Omega(\frac{N}{B})$
    - 当$B$足够大时,$MT(N)\geq O(\frac{N}{B})$

- 更好的分析,不使用叶节点数量,而是$N=B$的节点数量($L(B)=1$)
  - 等效于根节点是$\frac{N}{B}$的传输时间
  - 需要传输$(\frac{N}{B})^{0.8393}$次
  - $MT(N)=O(\frac{N}{B})$

### 3. 矩阵乘法
$$
C^{n\times n}=A\cdot B
$$

- 传统计算方法
  - A是行式存储,B是列式存储
  - 对于每个元素,需要$MT=O(\frac{n}{B})\rightarrow MT(n)=O(\frac{n^3}{B})$

- **更好的计算方法**

  - 把$A,B$拆成$2\times2$的子矩阵
    $$
    C=AB=\left[\begin{array}{cc}A_{11} & A_{12} \\A_{21} & A_{22}\end{array}\right]\cdot\left[\begin{array}{cc}B_{11} & B_{12} \\B_{21} & B_{22}\end{array}\right]=\left[\begin{array}{cc}A_{11}\cdot B_{11} & A_{11}\cdot B_{12} \\A_{21}\cdot B_{11} & A_{21}\cdot B_{12} \\\end{array}\right]+\left[\begin{array}{cc}A_{12}\cdot B_{21} & A_{12}\cdot B_{22} \\A_{22}\cdot B_{21} & A_{22}\cdot B_{22} \\\end{array}\right]
    $$

  - $MT(n)=8(n/2)+O(\frac{n^2}{B})\rightarrow MT(n)=O(n^3)$
  - 终止条件:**缓存$M$里刚好放了三个submatrix**,此时边长$3n^2=M\rightarrow n=\sqrt{\frac{M}{3}}$
  - 缓存中数据总量是$\frac{M}{3}$,加载$O(\frac{M}{B})$次 $\rightarrow MT(\sqrt{\frac{M}{3}})=O(\frac{M}{B})$
  - 当边长是$O(\sqrt M)$时停止拆分$\rightarrow MT(n)=O((\frac{n}{\sqrt M})^3)\times O(\frac{M}{B})=O(\frac{n^3}{B\sqrt M})$



### 4. 静态搜索树

**访问有N个节点的二叉树的叶子（对多路树同样有效）**

- 将二叉树根据高度$\log N$对半分,直到$N\leq B$为止

- 将分割后的每颗子树放在1个block的大小里

  <img src="C:\Users\PANDA\AppData\Roaming\Typora\typora-user-images\image-20210501155424842.png" alt="image-20210501155424842" style="zoom:50%;" />

  - 读取节点数小于B的子树,最多访问两次block, $MT(N)=O(1)\leq2\text{ for }N\leq B$
  - 每颗子树的高度$\frac{1}{2}\log B< h\leq \log B$. 下界源于当高度刚好为$B+1$时还要额外分一次

- 从高度出发每一次遍历的三角形数量$MT=h(tree)/h(cache)\leq2\log N/\log B$

- 总耗时$MT(N)=O(4\log N/\log B)=O(\log_B N)$



### 5. 排序

#### 5.1 用搜索树排序

$MT(N)=N\cdot O(\log_BN)=O(N\log_BN)$

#### 5.2 merge sort

- $MT(N)=2MT(\frac{N}{2})+O(\frac{N}{B})\rightarrow MT(N)=O(N\log N)$
- 当数据量为$M$时, $MT(M)=O(\frac{M}{B})\rightarrow MT(N)=O(\frac{N}{B}\log\frac{N}{M})$

#### 5.3 缓存相关merge sort

将数据分成$\frac{M}{B}$份 (**必须知道M和B才可以操作**)

**使得每个sub array至少有一个cache block可以用**

- $MT(N)=\frac{M}{B}MT(\frac{N\cdot B}{M})+O(\frac{N}{B})$

- 当数据量为$M$时, $MT(M)=O(\frac{M}{B})$
- 递归树高度 $h=\log_{M/B}\frac{N}{M}+1=\log_{M/B}\frac{N}{B}$

- 总$MT=$每层$MT\times h=\frac{N}{B}\log_{M/B}\frac{N}{B}$

#### 5.4 缓存无关高效merge sort

​	采用高效缓存merge

1. 先估计cache的大小 $M=\Omega(B^{1+\epsilon})$

   $M=B^2$即可

2. 使用 $\epsilon$路merge sort 
3. 取$\epsilon=\frac{1}{3}$，则使用过$N^\frac{1}{3}=K$路merge sort
4. **假设已知merge的消耗**$MT(N)=O(\frac{K^3}{B}\log_\frac{M}{B}\frac{K^3}{B}+K)$
5. 得到$MT(N)=N_{\frac{1}{3}}MT(N^\frac{2}{3})+O(\frac{N}{B}\log_\frac{M}{B}\frac{N}{B}+N^\frac{1}{3})$

6. 假设$N=\Omega(M)=\Omega(B^2)$,则$\frac{N}{B}=\Omega(\sqrt{N})=\Omega(N^\frac{1}{3})$

7. 由于$\log_\frac{M}{B}\frac{N}{B}>1$(5)中merge的消耗变成$O(\frac{N}{B}\log_\frac{M}{B}\frac{N}{B})$
8. 递归树每一层减小$\frac{2}{3}$
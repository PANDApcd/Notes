# 算法分析

### 1. 常用的算法评价标准

1. 正确性
   - 稳定性
   - 边界条件
2. 性能
   - 时间复杂度
   - 空间复杂度
3. 安全性
4. 可维护性
   - 模块化
   - python vs c++



### 2. 渐进分析（复杂度分析）

​	本质上,忽视**不同计算机间的区别**。

​	当问题**足够大**的时候,复杂度低的算法总会效果更好（**有时候需要思考足够大是多大**）

 1. 场景

    - 最坏情况
    - 期望情况,需要考虑输入的**分布**,并加权

	2. 复杂度描述符,对于任意c都可以**得到规模大小n使不等式成立**

    2.1 $O(n)$ 决定上界

    2.2 $\Omega(n)$ 决定下界

    2.3 $\Theta(n)$ **同时包括上下界**



### 3. 递归方程

1. 解法

   1.1 **代换法**

   - 猜测表达式，用表达式替代原公式，再用数学归纳法自底向上证明

   1.2 递归树法

   - 先猜测复杂度

   - 一层一层求**非递归项的和并累加**

     

2. **Master Theorem**

   主理论

   ​	可以通过递归树证明,高度为$\log_b n$，叶节点数量为$a^{\log_b n}$

   - **拿$f(n)$的复杂度和$n^{\log_b a}$做比较**
   
   $$
   T(n)=aT(n/b) + f(n) \\
\text{ s.t   } a\ge1,b>1
   $$
   
   - 如果$f(n)=O(n^{\log_b a-\omega})$, 即**f(n)更小,则$T(n)$受限于**$n^{\log_b a}$
     $$
     T(n)=\Theta(n^{\log_ba})
     $$
     
   - 如果$f(n)=\Theta(n^{\log_b a})$, 即**f(n)很接近,则$T(n)$受限于**$n^{\log_b a}\log n$
     $$
     T(n)=\Theta(n^{\log_ba}\log n)
     $$
   
   - 如果$f(n)=\theta(n^{\log_b a}\log^k n)$,**即f(n)大log阶,则**$T(n)$**受限于**$\log nf(n)$
        $$
        T(n)=\theta(n^{\log_b a}\log^{k+1}n)
        $$
        
        
   - 如果$f(n)=\Omega(n^{\log_b a+\omega})$, 即**f(n)更大,则$T(n)$受限于**$f(n)$
        $$
        T(n)=\Theta(f(n))
        $$


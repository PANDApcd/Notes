# 并行算法

### 1. 符号表示

$T_i$: 所有操作在$i$个处理器上串行执行的耗时

$T_{\infty}$:最长串行路径的耗时(有无穷个处理器的耗时)

$T_1\geq T_p\geq T_\infty$

加速比$T_1/T_p$

**最大加速比**$T_1/T_\infty=\bar{P}$,平均每步并行操作做的功



### 2.调度算法

#### 2.1 贪婪调度

- 一空闲就执行下一个任务
- 耗时$T_p\leq T_\infty+T_1/p$,**小于最优耗时的两倍**
  - 完成状态,当前可以运行的线程数大于$P$,最多有$T_1/P$个
  - 非完成状态,当前可以运行的任务数小于$P$,最多有$T_\infty$个
- 每次执行完in-degree=0的线程,$T_\infty$-=1



### 3. 矩阵乘法

$$
C=AB=
\left[\begin{array}{cc}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{array}\right]
\cdot
\left[\begin{array}{cc}
B_{11} & B_{12} \\
B_{21} & B_{22}
\end{array}\right]
=
\left[\begin{array}{cc}
A_{11}\cdot B_{11} & A_{11}\cdot B_{12} \\
A_{21}\cdot B_{11} & A_{21}\cdot B_{12} \\
\end{array}\right]x
+
\left[\begin{array}{cc}
A_{12}\cdot B_{21} & A_{12}\cdot B_{22} \\
A_{22}\cdot B_{21} & A_{22}\cdot B_{22} \\
\end{array}\right]
$$

**单进程计算**

- 加法 $A_1(n)=4A_1(n/2)+O(n)\rightarrow A_1(n)=O(n^2)$
- 乘法 $M_1(n)=8M_1(n/2)+O(n^2)\rightarrow M_1(n)=O(n^3)$

**多线程计算（8进程）**

- 加法 $A_\infty(n)=A_\infty(n/2)+O(n)\rightarrow A_\infty(n)=O(\log n)$

- 乘法 $M_\infty(n)=M_\infty(n/2)+O(\log n)\rightarrow M_\infty(n)=O(\log^2n)$

并行度$\bar{P}=O(\frac{n^3}{\log^2n})$

<u>**过高的并行度意义不大,有时候降低并行度来节约内存更重要**</u>



多进程计算（**4**进程）

- 加法 $A_\infty=O(\log n)$
- 乘法 $M_\infty(n)=2M_\infty(n/2)+O(\log n) \rightarrow M_\infty(n)=O(n)$



### 4. 并行排序

merge sort

**单进程计算**

$T_1(n)=2T_1(n/2)+O(n)\rightarrow T_1(n)=O(n\log n)$

**多进程计算**

$T_\infty(n)=T_\infty(n/2)+O(n)\rightarrow T_\infty(n)=O(n) $ **瓶颈在merge**

并行度 $\bar{P}=O(\log n)$, 并行度低,对于小规模处理器很有用

**多进程merge**

- 找到A(**大数组**)的中位数在B中的位置,再分别merge A和B的前后两部分

- $T_\infty(n)=T_\infty(\frac{3n}{4})+O(\log n)\rightarrow T_\infty(n)=O(\log^2 n)$
- $T_1(n)=T_1(\alpha\cdot n)+T_1((1-\alpha)n)+O(\log n)\rightarrow T_1(n)=O(n)$
- 总排序时间 $T_\infty=T_\infty(n/2)+O(\log ^2n)\rightarrow T_\infty(n)=O(\log ^3n)$

- 并行度$\bar{T}=O(\frac{n}{\log^2n})$